import ast
import os
import sys
import argparse
from pathlib import Path
from ._method_stubs import STUBS
from operator import attrgetter

TARGET_SUPERCLASSES = [
    "InboundAdapter",
    "BusinessService",
    "BusinessProcess",
    "BusinessOperation",
    "OutboundAdapter",
]

MESSAGE_SUPERCLASSES = [ "JsonSerialize", "PickleSerialize"]

# ——— local datatype map ———


DATATYPE_MAP = {"str": "%VarString", "int": "%Integer", "bool": "%Boolean"}

DATATYPE_MAP_Parameters = {"str": "STRING", "int": "INTEGER", "bool": "BOOLEAN"}


def extract_package_name(tree, default_name):
    for node in tree.body:
        if isinstance(node, ast.Assign):
            for target in node.targets:
                if isinstance(target, ast.Name) and target.id == "package_name":
                    if isinstance(node.value, ast.Constant) and isinstance(node.value.value, str):
                        return node.value.value
    return default_name


def real_filename(path):
    """
    Given a path (possibly with the wrong case), return the Path
    object that reflects the actual on-disk filename.
    Works on case-insensitive and case-sensitive filesystems.
    """
    p = Path(path)
    parent = p.parent if p.parent.exists() else Path(".")
    try:
        # Iterate through actual entries in parent dir
        for entry in parent.iterdir():
            if entry.name.lower() == p.name.lower():
                # Found matching filename (correct casing on disk)
                return entry
    except OSError:
        pass
    # Fallback: just return what you passed in
    return p


def load_to_iris(cls_string, cls_name):
    try:
        # required = ["IRISUSERNAME", "IRISPASSWORD", "IRISNAMESPACE", "IRISINSTALLDIR"]
        # ensure_env(required)
        # set_derived_env_vars()
        import iris

        print(f"Loading {cls_name} to IRIS...")
        iris_stream = iris._Stream.GlobalCharacter._New()
        iris_stream.Write(cls_string)
        iris._SYSTEM.OBJ.LoadStream(iris_stream, "ck")
    except Exception as e:
        print(
            f"Failed to load {cls_name} to iris. It is possible that an env variable was not set correctly. You can try to "
            "manually load the .cls files generated by this script using -o /path/to/output_folder"
        )
        print(
            "Here are some possible error messages and their meaning:"
            "No module named 'iris': You need to set the PYTHONPATH environment variable to point to /iris_install_dir/lib/python"
        )
        print(e)


# _______________________________________________________________________________________________________________________ load_to_iris #


def get_class_module_ast(cls) -> ast.Module:
    import inspect

    """Return the AST of the .py file where superclass is defined (assumes UTF-8)."""
    file_path = inspect.getsourcefile(cls)
    if file_path is None:
        raise RuntimeError(f"Cannot find a .py source file for {cls!r}")

    return Path(file_path).resolve()


# _______________________________________________________________________________________________________________________ get_class_module_ast #


def detect_custom_classes(tree, script_path, script_name, output, manual):
    import importlib.util
    import sys
    import os

    script_dir = os.path.dirname(script_path)
    if script_dir not in sys.path:
        sys.path.insert(0, script_dir)

    spec = importlib.util.spec_from_file_location(script_name, script_path)
    my_module = importlib.util.module_from_spec(spec)
    sys.modules[spec.name] = my_module
    spec.loader.exec_module(my_module)

    result = []
    superclasspathlist = set()
    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef):
            for base in node.bases:
                name = getattr(base, "id", getattr(base, "attr", None))
                if name in TARGET_SUPERCLASSES:
                    pass  # This case has already been handled
                else:
                    clsobj = getattr(my_module, node.name, None)
                    if clsobj is not None:
                        if (hostname := getattr(clsobj, "_hostname", None)) is not None:
                            if hostname in TARGET_SUPERCLASSES:
                                superclass = attrgetter(ast.unparse(base))(my_module)
                                superclassname = superclass._fullname
                                superclasspath = get_class_module_ast(superclass)
                                if superclasspath not in _visited_paths:
                                    superclasspathlist.add(superclasspath)

                                result.append((node.name, superclassname, node, hostname))

    for superclasspath in superclasspathlist:
        if superclasspath in _visited_paths:
            continue
        next_argv = [str(superclasspath)]
        if output:
            next_argv += ["-o", output]
        if manual:
            next_argv += ["-m"]
        main(next_argv)

    return result


def generate_custom_classes( tree, script_name, folder_name, package_name, output, script_path, manual, real_path):

    python_library = f"{folder_name}.{script_name}"
    classes = detect_custom_classes(tree, real_path, script_name, output, manual)
    if not classes:
        return
    class_tmpl = STUBS.get("ClassDefinition")
    common_oninit = STUBS.get("Common", {}).get("OnInit", "")
    bp_oninit = STUBS.get("Common", {}).get("OnInitBP", "")

    all_classes = {}
    for cls_name, supercls, node, hostname in classes:
        # Build OnInit method
        props_lines, settings_list = extract_props_and_settings(node, real_path)
        props_block = "\n".join(props_lines) if props_lines else ""

        # params = []
        params_settings = (
            f'Parameter SETTINGS = "{",".join(settings_list)}";'
            if settings_list else ""
        )

        param_lines = extract_params(node)

        param_lines.append(params_settings)

        params_block = "\n".join(param_lines) if param_lines else ""

        # params.append(param_setting)

        # code for getting all parameters
        if hostname == "BusinessProcess":
            oninit = bp_oninit.format(
                ClassName=cls_name,
                PackageName=package_name,
                PythonLibrary=python_library,
                Superclass=supercls,
                ScriptPath=script_path,
                ScriptName=script_name,
            )
        else:
            oninit = common_oninit.format(
                ClassName=cls_name,
                PackageName=package_name,
                PythonLibrary=python_library,
                Superclass=supercls,
                ScriptPath=script_path,
                ScriptName=script_name,
            )

        methods = [oninit]
        super_stubs = STUBS.get(hostname, {})

        # Inspect user-defined methods
        for child in node.body:
            if isinstance(child, ast.FunctionDef):

                name = child.name
                args_string = get_args(child)
                # Determine stub: specific stub or AnyMethod for certain superclasses
                if name in super_stubs:
                    stub_tmpl = super_stubs[name]
                elif (
                    hostname in ("BusinessOperation", "OutboundAdapter")
                    and "AnyMethod" in super_stubs
                ):
                    stub_tmpl = super_stubs["AnyMethod"]
                else:
                    continue

                # Fill method stub, include MethodName for AnyMethod templates
                content_stub = stub_tmpl.format(
                    ClassName=cls_name,
                    PackageName=package_name,
                    PythonLibrary=python_library,
                    Superclass=supercls,
                    MethodName=name,
                    Arguments=args_string,
                    ScriptPath=script_path,
                    ScriptName=script_name,
                )
                methods.append(content_stub)
        methods_combined = "\n".join(methods)

        # Fill the class template
        content = class_tmpl.format(
            ClassName=cls_name,
            PackageName=package_name,
            Superclass=supercls,
            props=props_block,
            params=params_block,
            methods=methods_combined,
        )

        if manual and not output:
            script_path = Path(script_path).resolve()
            output = script_path / f"{package_name}_classes"
            output.mkdir(parents=True, exist_ok=True)

        if output:
            out_path = os.path.join(output, f"{cls_name}.cls")
            with open(out_path, "w") as f:
                f.write(content)
            print(f"Generated {out_path}")

        all_classes[cls_name] = content

    if not manual:
        for cls_name in all_classes.keys():
            load_to_iris(all_classes[cls_name], cls_name)


# _______________________________________________________________________________________________________________________ generate_custom_classes #


def get_args(func_node):
    args = func_node.args.args

    arg_list = []
    for arg in args:
        if arg.arg == "self":
            continue
        arg_list.append(arg.arg)

    arguments = ", ".join(arg_list)
    return arguments


def extract_params(node: ast.ClassDef):
    params = []

    for stmt in node.body:
        ann = None
        if isinstance(stmt, ast.Assign) and len(stmt.targets) == 1:
            target_node = stmt.targets[0]
            call_node = stmt.value
        elif isinstance(stmt, ast.AnnAssign) and isinstance(stmt.target, ast.Name):
            target_node = stmt.target
            call_node = stmt.value
            ann = stmt.annotation
        else:
            continue

        # now check it's really IRISParameter(...)
        if not (
            isinstance(call_node, ast.Call)
            and (
                (
                    isinstance(call_node.func, ast.Name)
                    and call_node.func.id == "IRISParameter"
                )
                or (
                    isinstance(call_node.func, ast.Attribute)
                    and call_node.func.attr == "IRISParameter"
                )
            )
        ):
            continue

        param_name = target_node.id

        # pull literal kwargs out of the call
        kw = {a.arg: ast.literal_eval(a.value) for a in call_node.keywords}

        desc = kw.get("description", None)
        dtype = kw.get("datatype", None)
        keyword_list = kw.get("keyword_list", None)
        value = kw.get("value", None)
        if dtype is None and ann is not None:
            dtype = DATATYPE_MAP_Parameters.get(ast.unparse(ann))

        if desc:
            params.append(f"/// {desc}")

        # build the Property line
        line = f"Parameter {param_name} "
        if dtype:
            line += f" As {dtype} "
        if keyword_list is not None:
            line += f" [{keyword_list}]"
        if value is not None:
            if isinstance(value, str):
                line += f' = "{value}"'
            else:
                line += f" = {value}"
        else:
            try:
                value = ast.literal_eval(call_node.args[0])
                if isinstance(value, str):
                    line += f' = "{value}"'
                else:
                    line += f" = {value}"
            except:
                print("Failed to parse value from IRISParameter call for {node}")

        line += "; \n"
        params.append(line)

    return params


def message_map_xdata(MessageMap):
    output = []
    output.append("XData MessageMap")
    output.append("{")
    output.append("  <MapItems>")

    for msg_type, method in MessageMap.items():
        output.append(f'    <MapItem MessageType="{msg_type}">')
        output.append(f"      <Method>{method}</Method>")
        output.append("    </MapItem>")

    output.append("  </MapItems>")
    output.append("}")

    result = "\n".join(output)
    return result


def extract_props_and_settings(node: ast.ClassDef, real_path):

    props, settings = [], []

    for stmt in node.body:
        ann = None
        if isinstance(stmt, ast.Assign) and len(stmt.targets) == 1:
            target_node = stmt.targets[0]
            call_node = stmt.value
        elif isinstance(stmt, ast.AnnAssign) and isinstance(stmt.target, ast.Name):
            target_node = stmt.target
            call_node = stmt.value
            ann = stmt.annotation
        else:
            continue

        if target_node.id.lower() == "messagemap":
            message_map_as_dictionary = {
                k.value: v.value for k, v in zip(call_node.keys, call_node.values)
            }
            message_map_as_xdata_string = message_map_xdata(message_map_as_dictionary)
            props.append(message_map_as_xdata_string)
            continue

        # now check it's really IRISProperty(...)
        if not (
            isinstance(call_node, ast.Call)
            and (
                (
                    isinstance(call_node.func, ast.Name)
                    and call_node.func.id == "IRISProperty"
                )
                or (
                    isinstance(call_node.func, ast.Attribute)
                    and call_node.func.attr == "IRISProperty"
                )
            )
        ):
            continue

        prop_name = target_node.id

        # pull literal kwargs out of the call
        kw = {a.arg: ast.literal_eval(a.value) for a in call_node.keywords}

        desc = kw.get("description", None)
        dtype = kw.get("datatype", None)
        default = kw.get("default", None)
        setting = kw.get("settings", None)
        if dtype is None and ann is not None:
            dtype = ast.unparse(ann)

        # build the property description line
        if desc:
            props.append(f"/// {desc}")

        # build the Property line
        datatype = DATATYPE_MAP.get(dtype, '%VarString')
        line = f"Property {prop_name} As {datatype}"
        if default is not None:
            if datatype == "%VarString":
                line += f' [InitialExpression = "{default}"]'
            else:
                line += f" [InitialExpression = {default}]"


        line += "; \n"
        props.append(line)

        if setting:
            settings.append(setting)

    return props, settings


def find_ossubclasses(tree):
    result = []
    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef):
            for base in node.bases:
                name = getattr(base, "id", getattr(base, "attr", None))
                if name in TARGET_SUPERCLASSES:
                    result.append((node.name, name, node))
    return result


def generate_os_classes(tree, script_name, folder_name, package_name, output, script_path, manual, real_path):

    python_library = f"{folder_name}.{script_name}"
    classes = find_ossubclasses(tree)
    class_tmpl = STUBS.get("ClassDefinition")
    common_oninit = STUBS.get("Common", {}).get("OnInit", "")
    bp_oninit = STUBS.get("Common", {}).get("OnInitBP", "")

    all_classes = {}
    for cls_name, supercls, node in classes:
        # Build OnInit method
        props_lines, settings_list = extract_props_and_settings(node, real_path)
        props_block = "\n".join(props_lines) if props_lines else ""

        # params = []
        params_settings = (
            f'Parameter SETTINGS = "{",".join(settings_list)}";'
            if settings_list else ""
        )

        param_lines = extract_params(node)

        param_lines.append(params_settings)

        params_block = "\n".join(param_lines) if param_lines else ""

        # params.append(param_setting)

        # code for getting all parameters
        if supercls == "BusinessProcess":
            oninit = bp_oninit.format(
                ClassName=cls_name,
                PackageName=package_name,
                PythonLibrary=python_library,
                Superclass=supercls,
                ScriptPath=script_path,
                ScriptName=script_name,
            )
        else:
            oninit = common_oninit.format(
                ClassName=cls_name,
                PackageName=package_name,
                PythonLibrary=python_library,
                Superclass=supercls,
                ScriptPath=script_path,
                ScriptName=script_name,
            )

        methods = [oninit]
        super_stubs = STUBS.get(supercls, {})

        # Inspect user-defined methods
        for child in node.body:
            if isinstance(child, ast.FunctionDef):

                name = child.name
                args_string = get_args(child)
                # Determine stub: specific stub or AnyMethod for certain superclasses
                if name in super_stubs:
                    stub_tmpl = super_stubs[name]
                elif (
                    supercls in ("BusinessOperation", "OutboundAdapter")
                    and "AnyMethod" in super_stubs
                ):
                    stub_tmpl = super_stubs["AnyMethod"]
                else:
                    continue

                # print(cls_name, supercls, name)
                # Fill method stub, include MethodName for AnyMethod templates
                content_stub = stub_tmpl.format(
                    ClassName=cls_name,
                    PackageName=package_name,
                    PythonLibrary=python_library,
                    Superclass=supercls,
                    MethodName=name,
                    Arguments=args_string,
                    ScriptPath=script_path,
                    ScriptName=script_name,
                )
                methods.append(content_stub)
        methods_combined = "\n".join(methods)

        # Fill the class template
        content = class_tmpl.format(
            ClassName=cls_name,
            PackageName=package_name,
            Superclass="Ens." + supercls,
            props=props_block,
            params=params_block,
            methods=methods_combined,
        )

        if manual and not output:
            script_path = Path(script_path).resolve()
            output = script_path / f"{package_name}_classes"
            output.mkdir(parents=True, exist_ok=True)

        if output:
            out_path = os.path.join(output, f"{cls_name}.cls")
            with open(out_path, "w") as f:
                f.write(content)
            print(f"Generated {out_path}")

        all_classes[cls_name] = content

    if not manual:
        for cls_name in all_classes.keys():
            load_to_iris(all_classes[cls_name], cls_name)


# _______________________________________________________________________________________________________________________ generate_os_classes #


def props_and_indices_from_msg_class(node: ast.ClassDef):
    props, indices = [], []

    for stmt in node.body:
        ann = None
        if isinstance(stmt, ast.Assign) and len(stmt.targets) == 1:
            target_node = stmt.targets[0]
            call_node = stmt.value
        elif isinstance(stmt, ast.AnnAssign) and isinstance(stmt.target, ast.Name):
            target_node = stmt.target
            call_node = stmt.value
            ann = stmt.annotation
        else:
            continue

        # now check it's really IRISProperty(...)
        if not (
            isinstance(call_node, ast.Call)
            and (
                (isinstance(call_node.func, ast.Name) and call_node.func.id == "Column")
                or (
                    isinstance(call_node.func, ast.Attribute)
                    and call_node.func.attr == "Column"
                )
            )
        ):
            continue

        prop_name = target_node.id

        # pull literal kwargs out of the call
        kw = {a.arg: ast.literal_eval(a.value) for a in call_node.keywords}

        index = kw.get("index", None)
        default = kw.get("default", None)
        desc = kw.get("description", None)
        dtype = kw.get("datatype", None)

        if dtype is None and ann is not None:
            dtype = ast.unparse(ann)

        # build the property description line
        if desc:
            props.append(f"/// {desc}")

        # build the Property line
        datatype = DATATYPE_MAP.get(dtype, "%VarString")
        line = f"Property {prop_name} As {datatype}"
        if default is not None:
            if datatype == "%VarString":
                line += f' [InitialExpression = "{default}"]'
            else:
                line += f" [InitialExpression = {default}]"

        line += "; \n"
        props.append(line)

        if index:
            index_line = f"INDEX {prop_name}IDX ON {prop_name}"
            index_line += "; \n"
            indices.append(index_line)

    return props, indices


def find_custom_message_classes(tree, script_path, script_name, output, manual):

    import importlib.util
    import sys
    import os

    result = []

    script_dir = os.path.dirname(script_path)
    if script_dir not in sys.path:
        sys.path.insert(0, script_dir)

    spec = importlib.util.spec_from_file_location(script_name, script_path)
    my_module = importlib.util.module_from_spec(spec)
    sys.modules[spec.name] = my_module
    spec.loader.exec_module(my_module)

    superclasspathlist = set()
    for node in ast.walk(tree):
        if not isinstance(node, ast.ClassDef):
            continue

        # Check each base class for a match
        for base in node.bases:
            name = getattr(base, "id", None) or getattr(base, "attr", None)
            if name in MESSAGE_SUPERCLASSES:
                pass # This case has already been handled in find_message_classes()
            else:
                clsobj = getattr(my_module, node.name, None)
                if clsobj is not None:
                    if (serializer := getattr(clsobj, "_serializer", None)) is not None:
                        if serializer in MESSAGE_SUPERCLASSES:
                            superclass = attrgetter(ast.unparse(base))(my_module)
                            superclassname = superclass._fullname

                            superclasspath = get_class_module_ast(superclass)
                            if superclasspath not in _visited_paths_msgs:
                                superclasspathlist.add(superclasspath)

                            result.append((node.name, superclassname, node, serializer))
    for superclasspath in superclasspathlist:
        if superclasspath in _visited_paths_msgs:
            continue
        next_argv = [str(superclasspath)]
        if output:
            next_argv += ["-o", output]
        if manual:
            next_argv += ["-m"]
        main(next_argv)

    return result


def generate_custom_msg_wrappers(tree, script_name, folder_name, package_name, python_library, output, script_path, manual,real_path):
    classes = find_custom_message_classes(tree,real_path, script_name, output, manual)
    if not classes:
        return
    all_classes = {}
    for cls, superclass_name, node, serializer in classes:

        props_lines, indices = props_and_indices_from_msg_class(node)
        props_block = "\n".join(props_lines) if props_lines else ""
        indices_block = "\n".join(indices) if indices else ""

        stub = STUBS.get("MsgSubclass")
        if not stub:
            print("Missing MsgWrapperSuperClass stub for " + superclass_name)
            continue
        content = stub.format(
            ClassName=cls,
            PackageName=package_name,
            PythonLibrary=python_library,
            ScriptPath=script_path,
            ScriptName=script_name,
            props=props_block,
            indices=indices_block,
            Superclass=superclass_name
        )

        if manual and not output:
            script_path = Path(script_path).resolve()
            output = script_path / f"{package_name}_classes"
            output.mkdir(parents=True, exist_ok=True)

        if output:
            out_path = os.path.join(output, f"{cls}.cls")
            with open(out_path, "w") as f:
                f.write(content)
            print(f"Generated {out_path}")

        all_classes[cls] = content

    ## loading to IRIS. This might fail if env variables are not set correctly
    if not manual:
        for cls_name in all_classes.keys():
            load_to_iris(all_classes[cls_name], cls_name)


def find_message_classes(source):
    """
    Parse the given Python source, walk the AST, and return a list of
    (class_name, matched_base) for every class that directly inherits from
    PickleSerialize, JsonSerialize.
    """
    tree = ast.parse(source)
    result = []

    for node in ast.walk(tree):
        if not isinstance(node, ast.ClassDef):
            continue

        # Check each base class for a match
        for base in node.bases:
            name = getattr(base, "id", None) or getattr(base, "attr", None)
            if name in MESSAGE_SUPERCLASSES:
                result.append((node.name, name, node))
                break  # stop on first match per class

    return result


def generate_msg_wrappers(tree, script_name, folder_name, package_name, python_library, output, script_path, manual):
    classes = find_message_classes(tree)
    all_classes = {}
    for cls, superclass_name, node in classes:

        props_lines, indices = props_and_indices_from_msg_class(node)
        props_block = "\n".join(props_lines) if props_lines else ""
        indices_block = "\n".join(indices) if indices else ""

        stub = STUBS.get(superclass_name)
        if not stub:
            print("Missing MsgWrapperSuperClass stub for " + superclass_name)
            continue
        content = stub.format(
            ClassName=cls,
            PackageName=package_name,
            PythonLibrary=python_library,
            ScriptPath=script_path,
            ScriptName=script_name,
            props=props_block,
            indices=indices_block,
        )

        if manual and not output:
            script_path = Path(script_path).resolve()
            output = script_path / f"{package_name}_classes"
            output.mkdir(parents=True, exist_ok=True)

        if output:
            out_path = os.path.join(output, f"{cls}.cls")
            with open(out_path, "w") as f:
                f.write(content)
            print(f"Generated {out_path}")

        all_classes[cls] = content

    ## loading to IRIS. This might fail if env variables are not set correctly
    if not manual:
        for cls_name in all_classes.keys():
            load_to_iris(all_classes[cls_name], cls_name)


# _______________________________________________________________________________________________________________________ generate_msg_wrappers #


_visited_paths: set[Path] = set()
_visited_paths_msgs: set[Path] = set()


def main(argv: list[str] = None):

    parser = argparse.ArgumentParser(description="Generate ObjectScript classes")
    parser.add_argument("input_script", help="Path to user script")
    parser.add_argument("-o", "--output", required=False, help="Output folder")
    parser.add_argument("-m", "--manual", action="store_true", help="Run in manual mode")
    args = parser.parse_args(argv)

    try:
        with open(args.input_script, "r") as f:
            real_path = real_filename(f.name).resolve()
            source = f.read()
    except Exception as e:
        print(f"Error reading input script: {e}")
        sys.exit(1)
    tree = ast.parse(source)

    script_name = real_path.stem
    script_path = real_path.parent
    folder_name = (
        os.path.basename(os.path.dirname(os.path.abspath(args.input_script)))
        or script_name
    )
    package_name = extract_package_name(tree, script_name)
    if args.output:
        os.makedirs(args.output, exist_ok=True)

    _visited_paths.add(real_path)
    _visited_paths_msgs.add(real_path)

    generate_msg_wrappers(
        tree,
        script_name,
        folder_name,
        package_name,
        f"{folder_name}.{script_name}",
        args.output,
        script_path,
        args.manual,
    )

    generate_custom_msg_wrappers(
        tree,
        script_name,
        folder_name,
        package_name,
        f"{folder_name}.{script_name}",
        args.output,
        script_path,
        args.manual,
        real_path,
    )

    generate_os_classes(
        tree,
        script_name,
        folder_name,
        package_name,
        args.output,
        script_path,
        args.manual,
        real_path,
    )

    generate_custom_classes(
        tree,
        script_name,
        folder_name,
        package_name,
        args.output,
        script_path,
        args.manual,
        real_path,
    )


if __name__ == "__main__":
    main()
